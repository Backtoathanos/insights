const id = "en/tsconfig-paths-setup/index.mdx";
						const collection = "blog";
						const slug = "en/tsconfig-paths-setup";
						const body = "\nTSConfig path aliases are a powerful tool that can help you to improve the readability, maintainability, and error-proofing of your TypeScript code. This allows for easier to read clean code, and enables us to move files around without having to update import paths in every file.\n\n_This is a huge time saver._\n\n## What Are Path Aliases?\n\nThe goal is to replace the following import statements:\n\n```ts\n// relative import path\nimport MyComponent from \"../../../components/MyComponent\";\n```\n\nwith these import statements:\n\n```ts\n// alias import path\nimport MyComponent from \"@components/MyComponent\";\n```\n\nWe can do this with a `tsconfig.json` or `jsconfig.json` file. We will be using TypeScript in this post.\n\n<Cta\n\tdescription=\"Premium Business Intelligence for Better ROI\"\n\tbuttonText=\"Get Started Now!\"\n\thref=\"\"\n/>\n\n## How To Setup Path Aliases\n\n### Adding Path Aliases To Your TSConfig File\n\nWe need to update our `tsconfig.json` file to enable aliases. We will add a `paths` and `baseUrl` property to the `compilerOptions` object. Each path is relative to the `baseUrl`.\n\nThis will tell TypeScript to replace the alias with the actual path when compiling the code.\n\n```json\n{\n\t\"compilerOptions\": {\n\t\t\"baseUrl\": \".\", // root of your \"paths\" below. Required if \"paths\" is defined\n\t\t\"paths\": {\n\t\t\t\"@components/*\": [\"src/components/*\"] // enables us to use @components/MyComponent\n\t\t}\n\t}\n}\n```\n\n### Using Path Aliases In Your Code\n\nNow in all of your source files, you can import components like this:\n\n```ts\n// Without path aliases\nimport Hero from \"../../../components/Hero\";\nimport Footer from \"../../../components/Footer\";\n\n// With path aliases\nimport Hero from \"@components/Hero\";\nimport Footer from \"@components/Footer\";\n```\n\n<Admonition variant=\"info\">\n\tFrameworks like Astro and Next.js ship with built-in typescript support, although you may have to\n\tcreate the file `tsconfig.json`. Consult your framework's documentation for more information.\n</Admonition>\n\n## Why Should I Do This?\n\nLet's say we have the following file structure:\n\n```\n.\n└── src/\n    ├── components/\n    │   ├── Hero.tsx\n    │   └── Footer.tsx\n    └── pages/\n        ├── index.tsx\n        └── solutions.tsx\n```\n\n### Annoying Relative Imports\n\nIf we want to import `Hero.tsx` and `Footer.tsx` into `index.tsx` and `solutions.tsx`, we would need the following import statements:\n\n```ts\nimport Hero from \"../components/Hero\";\nimport Footer from \"../components/Footer\";\n```\n\n### Refactoring Relative Imports\n\nNow lets say we want to refactor. We now have multiple \"solutions\" and want to have each on their own page, and have them under a `solutions` directory. The file structure now looks like:\n\n```\n.\n└── src/\n    ├── components/\n    │   ├── Hero.tsx\n    │   └── Footer.tsx\n    └── pages/\n        ├── index.tsx\n        └── solutions/\n            ├── solution.tsx\n            └── solution2.tsx\n```\n\nNow we have to update the import paths of `solution.tsx`:\n\n```ts\nimport Hero from \"../../components/Hero\";\nimport Footer from \"../../components/Footer\";\n```\n\nYou can see how this makes refactoring more of a chore. We have to update the import paths in every file that imports these components. This is a huge time sink and can lead to bugs if you forget to update the import paths.\n\n### Alias Imports Version\n\nAlternatively, if from the start we were using aliases, we would not have to update any files using the components. This is far better for maintainability:\n\n```ts\nimport Hero from \"@components/Hero\";\nimport Footer from \"@components/Footer\";\n```\n\n<Admonition variant=\"info\">\n\tWith this method, *every* file that needs to import these components will import them the same\n\tway. This makes it easier to move files around without having to update import paths.\n</Admonition>\n\n## Additional Paths\n\nThis can be extended to any number of path aliases. Some other potential ones you might use:\n\n```json\n{\n\t\"compilerOptions\": {\n\t\t\"baseUrl\": \".\",\n\t\t\"paths\": {\n\t\t\t\"@config/*\": [\"src/data/*\"],\n\t\t\t\"@js/*\": [\"src/js/*\"],\n\t\t\t\"@layouts/*\": [\"src/layouts/*\"],\n\t\t\t\"@components/*\": [\"src/components/*\"],\n\t\t\t\"@assets/*\": [\"src/assets/*\"]\n\t\t}\n\t}\n}\n```\n\n<Admonition variant=\"tip\">\n\tWhen updating `tsconfig.json`, you may need to restart your editor for the changes to take effect.\n</Admonition>\n";
						const data = {title:"How to Use TSConfig Path Aliases to Improve Your Code",description:"Enable cleaner, more readable import statements with TSConfig path aliases. Learn how to set them up and improve your TypeScript code maintainability.",authors:[{slug:"web-reaper",collection:"authors"}],pubDate:new Date(1691971200000),heroImage:
						new Proxy({"src":"/_astro/heroImage.x_EbSBIW.jpg","width":1920,"height":1280,"format":"jpg","fsPath":"/home/blackridgeorg/public_html/src/content/blog/en/tsconfig-paths-setup/heroImage.jpg"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "/home/blackridgeorg/public_html/src/content/blog/en/tsconfig-paths-setup/heroImage.jpg";
							}
							
							return target[name];
						}
					})
					,categories:["productivity"],draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/blackridgeorg/public_html/src/content/blog/en/tsconfig-paths-setup/index.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
